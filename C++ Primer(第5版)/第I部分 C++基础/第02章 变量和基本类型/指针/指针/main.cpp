//
//  main.cpp
//  指针
//
//  Created by Enrica on 2018/7/18.
//  Copyright © 2018 Enrica. All rights reserved.
//

#include <iostream>
#include <cstdlib>

int main(int argc, const char * argv[]) {
    
    // 引用
    int ival1 = 10, ival2 = 20;
    
    // 让引用指向某个已经存在的变量
    int &irefVal = ival1;
    std::cout << "irelVal = " << irefVal << std::endl;
    
    irefVal = ival2;  // 修改引用指向的变量
    std::cout << "irelVal = " << irefVal << std::endl;
    
    
    
    
    /**
     * 指针是指向另外一种类型的符合类型。与引用类似，指针也实现了对其他对象的间接访问。
     * 只不过，指针和引用比起来，又有一些不同点:
     * - (1)、指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的声明周期内它可以
     *   先后指向不同的对象；
     * - (2)、指针无需在定义时赋初值。和其它类型一样，在块作用域内定义的指针，如果没有
     *   对其进行初始化，那么它所拥有的值是不确定的(指向未知内存地址)。
     * 定义指针的方式和定义引用类似，只不过是将声明写成*d的形式，其中d是变量名
     */
    int *ip = &ival1;  // 它表示指针ip存放的是变量ival1的内存地址；或者说指针ip指向变量ival1
    std::cout << "指针ip指向变量的内存地址是: " << ip << std::endl;
    
    // 对指针解引用会得到指针所指向对象的值。因此，如果给指针解引用赋值，那么实际上是
    // 给指针所指向的对象赋值
    std::cout << "指针ip所指向变量的值是: " << *ip << std::endl;  // *p表示解引用
    
    *ip = 100;  // 给*ip赋值，实际上是给指针ip所指向的对象赋值
    std::cout << "*ip所指向对象的值为: " << *ip << std::endl;
    std::cout << "*ip所指向对象的值为: " << ival1 << std::endl;
    
    // 注意: 解引用操作仅适用于针对有效指针。如果对一个无效的指针执行
    // 解引用操作，会导致系统崩溃
    int *dp;  // 仅仅只是声明了指针dp，但是没有进行初始化，此时它指向不确定的对象
    std::cout << "dp所指向的内存地址为: " << dp << std::endl;  // 此时指针的地址具有不确定性
    // std::cout << "dp所指向对象的值为: " << *dp << std::endl;  // 对一个指向不确定对象的指针解引用是一件很危险的事情
    
    
    /**
     * 注意: 未经初始化的指针是引发运行时错误的一大原因。因此，在使用指针的时候一定要特别注意！
     */
    
    
    // 空指针
    int *p1 = nullptr;  // 等价于: int *p1 = 0;  nullptr是C++11新标准，它可以被转换为任意其它的指针类型
    int *p2 = 0;  // 通过字面量语法来生成空指针
    int *p3 = NULL;  // 等价于: int *p3 = 0;
    std::cout << "指针p1的地址为: " << p1 << std::endl;
    std::cout << "指针p2的地址为: " << p2 << std::endl;
    std::cout << "指针p3的地址为: " << p3 << std::endl;
    
    /**
     * 在使用指针之前，一定要初始化所有的指针，并且尽可能的在定义了对象之后，再去定义指向该对象的指针。
     * 如果是在是不知道指针应该指向何处，建议把它初始化为nullptr或者0，这样程序就能检测并知道它有没
     * 有指向合法的对象了
     */
    
    return 0;
}
